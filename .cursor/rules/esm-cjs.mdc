---
description: 
globs: 
alwaysApply: false
---
\
---
description: Guidelines for developing and maintaining dual ESM and CommonJS support.
globs: ["src/**/*.ts", "scripts/build-cjs.mjs", "package.json", "tsconfig*.json"]
alwaysApply: false
---

# Dual ESM/CJS Packaging Guidelines

This project supports both ECMAScript Modules (ESM) and CommonJS (CJS) to ensure broad compatibility. This document outlines key considerations and processes for developers.

## Overview

- **Primary Source Format**: Code in `src/` is written in TypeScript using ESM syntax.
- **ESM Build**: `tsc` (using `tsconfig.json`) compiles `src/` to `dist/esm/`. This is the primary modern output.
- **CJS Build**: The `scripts/build-cjs.mjs` script orchestrates the CJS build:
    1. It uses `tsc` with `tsconfig.cjs.json` to compile TypeScript sources (including `.cjs.ts` files) to JavaScript, initially outputting to `dist/cjs/` with `.js` extensions.
    2. It then post-processes the output in `dist/cjs/`:
        - Renames all `.js` files to `.cjs`.
        - Specifically handles files compiled from `.cjs.ts` (e.g., `utils/importMetaUrl.cjs.ts` becomes `utils/importMetaUrl.cjs`).
        - Updates `require()` paths in the generated `.cjs` files to point to other `.cjs` files correctly.
        - Applies specific fixes, like resolving `__dirname` conflicts (see `fixOpenAIDirnameConflict` function).

## Key Considerations for Developers

### 1. `import.meta.url`

   - **Purpose**: Used to get the absolute URL of the current module, often for path resolution.
   - **ESM (`src/**/*.ts`)**:
     - You can use `import.meta.url` directly.
     - It's recommended to use the `getImportMetaUrl()` utility from `@src/utils/importMetaUrl.ts`.
   - **CJS (`.cjs.ts` files and CJS context)**:
     - `import.meta.url` is not available.
     - The CJS-specific utility `src/utils/importMetaUrl.cjs.ts` provides an equivalent `getImportMetaUrl()`. This file is compiled by `tsc` (as part of the CJS build) into `dist/cjs/utils/importMetaUrl.cjs`.
   - **Build Script Handling**:
     - During the CJS build step (`tsc --project tsconfig.cjs.json`), the `scripts/build-cjs.mjs` script temporarily replaces the content of `src/utils/importMetaUrl.ts` with a benign placeholder. This is done because the standard ESM `importMetaUrl.ts` (if imported by other files being compiled to CJS) would cause a compile error due to `import.meta.url`.
     - After `tsc` completes, the original `src/utils/importMetaUrl.ts` is restored. The CJS build relies on the correctly compiled `dist/cjs/utils/importMetaUrl.cjs` (from `src/utils/importMetaUrl.cjs.ts`).

### 2. `__dirname` and `__filename`

   - **ESM**: These global variables are not available. To get equivalent paths:
     ```typescript
     import { fileURLToPath } from 'url';
     import { dirname } from 'path';

     const __filename = fileURLToPath(import.meta.url);
     const __dirname = dirname(__filename);
     ```
     (This is essentially what `src/utils/importMetaUrl.ts` and `src/utils/importMetaUrl.cjs.ts` encapsulate).
   - **CJS**: These are available directly.
   - **Potential Conflicts**:
     - The `tsc` compilation of `src/utils/importMetaUrl.cjs.ts` (which might create its own `__dirname` for CJS compatibility) can conflict with Node's built-in `__dirname` if not handled carefully.
     - The `fixOpenAIDirnameConflict` function in `scripts/build-cjs.mjs` is an example of a targeted fix for such a conflict that arose in the OpenAI adapter. It renames the `const __dirname = ...getDirname()` line generated by `tsc` to `const customDirname = ...` and updates its specific usage.

### 3. `package.json` Configuration

   - **`"type": "module"`**: Essential for Node.js to treat `.js` files as ESM by default.
   - **`"main": "dist/cjs/index.cjs"`**: Entry point for CommonJS `require()`.
   - **`"module": "dist/esm/index.js"`**: Entry point for ESM `import`.
   - **`"exports"` field**: Provides conditional exports, allowing Node.js to pick the correct module format based on how the package is imported. This is crucial for dual-package compatibility.
     ```json
     "exports": {
       ".": {
         "import": "./dist/esm/index.js", // For ESM imports
         "require": "./dist/cjs/index.cjs", // For CJS requires
         "types": "./dist/esm/index.d.ts"
       },
       // ... other exports for submodules
     }
     ```

### 4. TypeScript Configuration Files

   - **`tsconfig.json`**: Used for the primary ESM build (`yarn build`) and for editor intellisense. Outputs to `dist/esm`.
   - **`tsconfig.cjs.json`**: Extends `tsconfig.json` but overrides `"module": "CommonJS"` and `"outDir": "dist/cjs"`. Used by `scripts/build-cjs.mjs`.

### 5. Dependencies

   - **Pure ESM Dependencies**: If you add a dependency that is *only* available as an ESM package, it cannot be directly `require()`'d by the CJS build. This might require:
     - Bundling strategies for the CJS version.
     - Conditional imports/requires in your code (can get complex).
     - Avoiding such dependencies if CJS compatibility is critical and no workaround is feasible.
   - **CJS Dependencies**: Generally, these can be imported by ESM code and `require()`'d by CJS code.

### 6. Testing

   - Ensure your test suite (`yarn test`) covers functionality that might behave differently or be sourced differently between ESM and CJS versions if such paths exist.
   - The `test-cjs-require.cjs` (now removed, but illustrative) was a simple smoke test. Consider adding automated smoke tests for CJS imports as part of your CI or test suite if CJS support is critical.

## Troubleshooting the CJS Build

1.  **Check Logs**: The `scripts/build-cjs.mjs` script provides console output. Pay attention to renaming steps and path update logs.
2.  **Inspect `dist/cjs/`**: Manually check the generated `.cjs` files for:
    - Correct `require()` paths (e.g., `require('./foo.cjs')` not `require('./foo.js')`).
    - Transpilation issues or unexpected transformations.
3.  **Verify `tsconfig.cjs.json`**: Ensure its settings are appropriate for CJS output.
4.  **Isolate Issues**: If a specific file fails, try to understand how `tsc` transpiled it and how `build-cjs.mjs` processed it.

## Adding New CJS-Specific Files (e.g., `*.cjs.ts`)

- If you need a module to have a distinct implementation for CJS (like `importMetaUrl.cjs.ts`), create it with the `.cjs.ts` extension in the `src/` directory.
- The `scripts/build-cjs.mjs` is designed to:
    1. Let `tsc --project tsconfig.cjs.json` compile it (e.g., `utils/importMetaUrl.cjs.ts` -> `dist/cjs/utils/importMetaUrl.cjs.js`).
    2. The `renameJsToCjs` function will rename it to `dist/cjs/utils/importMetaUrl.cjs.cjs` (temporary step).
    3. The `renameCompiledCJSTSFiles` function will finalize it to `dist/cjs/utils/importMetaUrl.cjs`.

This ensures that CJS-specific versions are correctly compiled and placed.

# References
- @scripts/build-cjs.mjs
- @package.json
- @tsconfig.json
- @tsconfig.cjs.json
- @src/utils/importMetaUrl.ts
- @src/utils/importMetaUrl.cjs.ts
