---
description: 
globs: 
alwaysApply: true
---
---
description: Core project rules that should always be considered when working with this codebase
globs: ["**/*"]
alwaysApply: true
---

# Project Overview
This is a universal LLM caller library designed to provide a unified interface for interacting with various language model providers, with a focus on streaming, schema validation, cost tracking, and retry mechanisms.

# Core Principles

## Type Safety
- NEVER use 'any' types
- Use `type` instead of `interface`
- Maintain strict type definitions
- Document all types thoroughly
- Ensure proper error handling with type safety

## Code Architecture
- Follow functional and declarative programming patterns
- Keep code modular and maintainable
- Use pure functions where possible
- Maintain clear separation of concerns
- Preserve existing functionality unless explicitly required to change

## Development Process
1. Before any changes:
   - Understand the task scope
   - Read relevant code sections
   - Create MECE (Mutually Exclusive, Collectively Exhaustive) task breakdown

2. During development:
   - Focus only on the task at hand
   - Preserve existing functionality
   - Maintain all comments
   - Ensure type safety
   - Use radash functions for complex operations

3. After changes:
   - Run and analyze tests
   - Ensure changes don't break existing functionality
   - Update documentation as needed
   - Reflect on lessons learned

## Code Standards
- Use lowercase-with-dashes for directories
- Use camelCase for variables and filenames
- Prefer named exports
- Keep variable names descriptive
- Add concise comments for non-obvious logic
- Mark potential improvements with TODO comments

## Error Handling
- Implement comprehensive error handling
- Use RetryManager for transient failures
- Maintain proper error context
- Add descriptive error messages

## Testing Requirements
- All tests must be in the `./tests` directory
- Maintain minimum 90% test coverage
- Test both success and error paths
- Test streaming scenarios thoroughly
- Verify token calculation accuracy
- Test JSON mode with different schema complexities

## Streaming Implementation
- NEVER implement fake streaming (i.e., sending a non-streaming request and then streaming the complete response)
- NEVER include mock/hard-coded data in streaming implementations (except in tests and examples)
- Properly handle tool calls during streaming, collecting tool arguments before execution
- Ensure retry policy, JSON mode, and tool calling work correctly with streaming


# References
- See @.cursor/rules/architecture.mdc for detailed architectural decisions
- See @.cursor/rules/testing.mdc for testing conventions
- See @src/core/types.ts for type definitions
